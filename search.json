[{"title":"高质量编程以及性能测试","date":"2022-05-11T09:59:18.384Z","url":"/2022/05/11/%E9%AB%98%E8%B4%A8%E9%87%8F%E7%BC%96%E7%A8%8B-%E6%AD%A3%E7%A1%AE%E5%8F%AF%E9%9D%A0%EF%BC%8C%E6%B8%85%E6%99%B0%E7%AE%80%E6%B4%81/","categories":[["学习","/categories/%E5%AD%A6%E4%B9%A0/"]],"content":"高质量编程-正确可靠，清晰简洁简单性：消除多余的复杂性，以清晰的逻辑编辑代码。 可读性：编写可维护代码的第一步是确保代码可读。 生产力：团队整体工作效率。 代码格式： 使用 gofmt 自动格式化代码，保证所有的 Go 代码与官方推荐格式保持一致 注释： 注释应该解释代码作用 注释应该解释代码如何做的 注释应该解释代码实现的原因 注释应该解释代码什么情况会出错 公共符号始终要注释 命名规范：变量名： 简洁胜于冗长 缩略词全大写，但当其位于变量开头且不需要导出时，使用全小写 变量距离其被使用的地方越远，则需要携带越多的上下文信息 全局变量在其名字中需要更多的上下文信息，使得在不同地方可以轻易辨认出其含义 函数名： 函数名不携带包名的上下文信息，因为包名和函数名总是成对出现的 函数名尽量简短 当名为 foo 的包某个函数返回类型 Foo 时，可以省略类型信息而不导致歧义 当名为 foo 的包某个函数返回类型 T 时（T 并不是 Foo），可以在函数名中加入类型信息 包名： 只由小写字母组成。不包含大写字母和下划线等字符 简短并包含一定的上下文信息。例如 schema、task 等 不要与标准库同名。例如不要使用 sync 或者 strings 控制流程： 避免嵌套，保持正常流程清晰 如果两个分支中都包含 return 语句，则可以去除冗余的 else 尽量保持正常代码路径为最小缩进，优先处理错误情况&#x2F;特殊情况，并尽早返回或继续循环来减少嵌套，增加可读性 简单错误处理 优先使用 errors.New 来创建匿名变量来直接表示该错误。有格式化需求时使用 fmt.Errorf 错误的 Wrap 和 Unwrap 在 fmt.Errorf 中使用 %w 关键字来将一个错误 wrap 至其错误链中 错误判定 使用 errors.Is 可以判定错误链上的所有错误是否含有特定的错误。 在错误链上获取特定种类的错误，使用 errors.As panic 不建议在业务代码中使用 panic 如果当前 goroutine 中所有 deferred 函数都不包含 recover 就会造成整个程序崩溃 当程序启动阶段发生不可逆转的错误时，可以在 init 或 main 函数中使用 panic recover recover 只能在被 defer 的函数中使用，嵌套无法生效，只在当前 goroutine 生效 如果需要更多的上下文信息，可以 recover 后在 log 中记录当前的调用栈。 性能优化建议 在满足正确性、可靠性、健壮性、可读性等质量因素的前提下，设法提高程序的效率 工具：Benchmark slice 预分配内存 在尽可能的情况下，在使用 make() 初始化切片时提供容量信息，特别是在追加切片时 原理 ueokande.github.io&#x2F;go-slice-tr… 切片本质是一个数组片段的描述，包括了数组的指针，这个片段的长度和容量(不改变内存分配情况下的最大长度) 切片操作并不复制切片指向的元素，创建一个新的切片会复用原来切片的底层数组，因此切片操作是非常高效的 切片有三个属性，指针(ptr)、长度(len) 和容量(cap)。append 时有两种场景： 当 append 之后的长度小于等于 cap，将会直接利用原底层数组剩余的空间 当 append 后的长度大于 cap 时，则会分配一块更大的区域来容纳新的底层数组 因此，为了避免内存发生拷贝，如果能够知道最终的切片的大小，预先设置 cap 的值能够获得最好的性能 另一个陷阱：大内存得不到释放 在已有切片的基础上进行切片，不会创建新的底层数组。因为原来的底层数组没有发生变化，内存会一直占用，直到没有变量引用该数组 因此很可能出现这么一种情况，原切片由大量的元素构成，但是我们在原切片的基础上切片，虽然只使用了很小一段，但底层数组在内存中仍然占据了大量空间，得不到释放 推荐的做法，使用 copy 替代 re-slice 性能优化建议 在满足正确性、可靠性、健壮性、可读性等质量因素的前提下，设法提高程序的效率 性能对比测试代码，可参考 github.com&#x2F;RaymondCode… slice 预分配内存 在尽可能的情况下，在使用 make() 初始化切片时提供容量信息，特别是在追加切片时 原理 ueokande.github.io&#x2F;go-slice-tr… 切片本质是一个数组片段的描述，包括了数组的指针，这个片段的长度和容量(不改变内存分配情况下的最大长度) 切片操作并不复制切片指向的元素，创建一个新的切片会复用原来切片的底层数组，因此切片操作是非常高效的 切片有三个属性，指针(ptr)、长度(len) 和容量(cap)。append 时有两种场景： 当 append 之后的长度小于等于 cap，将会直接利用原底层数组剩余的空间 当 append 后的长度大于 cap 时，则会分配一块更大的区域来容纳新的底层数组 因此，为了避免内存发生拷贝，如果能够知道最终的切片的大小，预先设置 cap 的值能够获得最好的性能 另一个陷阱：大内存得不到释放 在已有切片的基础上进行切片，不会创建新的底层数组。因为原来的底层数组没有发生变化，内存会一直占用，直到没有变量引用该数组 因此很可能出现这么一种情况，原切片由大量的元素构成，但是我们在原切片的基础上切片，虽然只使用了很小一段，但底层数组在内存中仍然占据了大量空间，得不到释放 推荐的做法，使用 copy 替代 re-slice map 预分配内存 原理 不断向 map 中添加元素的操作会触发 map 的扩容 根据实际需求提前预估好需要的空间 提前分配好空间可以减少内存拷贝和 Rehash 的消耗 使用 strings.Builder 常见的字符串拼接方式 strings.Builder bytes.Buffer strings.Builder 最快，bytes.Buffer 较快，+ 最慢 原理 字符串在 Go 语言中是不可变类型，占用内存大小是固定的，当使用 + 拼接 2 个字符串时，生成一个新的字符串，那么就需要开辟一段新的空间，新空间的大小是原来两个字符串的大小之和 strings.Builder，bytes.Buffer 的内存是以倍数申请的 strings.Builder 和 bytes.Buffer 底层都是 []byte 数组，bytes.Buffer 转化为字符串时重新申请了一块空间，存放生成的字符串变量，而 strings.Builder 直接将底层的 []byte 转换成了字符串类型返回 使用空结构体节省内存 空结构体不占据内存空间，可作为占位符使用 比如实现简单的 Set Go 语言标准库没有提供 Set 的实现，通常使用 map 来代替。对于集合场景，只需要用到 map 的键而不需要值 使用 atomic 包 原理 锁的实现是通过操作系统来实现，属于系统调用，atomic 操作是通过硬件实现的，效率比锁高很多 sync.Mutex 应该用来保护一段逻辑，不仅仅用于保护一个变量 对于非数值系列，可以使用 atomic.Value，atomic.Value 能承载一个 interface{} 性能优化性能调优简介性能调优原则 要依靠数据不是猜测 要定位最大瓶颈而不是细枝末节 不要过早优化 不要过度优化 性能优化分析工具:pprof 排查 CPU 问题 命令行分析 go tool pprof ““ top 命令 list 命令 熟悉 web 页面分析 调用关系图，火焰图 go tool pprof -http&#x3D;:8080 ““ 排查堆内存问题 go tool pprof -http&#x3D;:8080 ““ 排查协程问题 go tool pprof -http&#x3D;:8080 ““ 排查锁问题 go tool pprof -http&#x3D;:8080 ““ 排查阻塞问题 go tool pprof -http&#x3D;:8080 ““ pprof 的采样过程和原理 CPU 采样 堆内存采样 协程和系统线程采样 阻塞操作和锁竞争采样 性能调优案例 基本概念 服务：能单独部署，承载一定功能的程序 依赖：Service A 的功能实现依赖 Service B 的响应结果，称为 Service A 依赖 Service B 调用链路：能支持一个接口请求的相关服务集合及其相互之间的依赖关系 基础库：公共的工具包、中间件 业务优化 流程 建立服务性能评估手段 分析性能数据，定位性能瓶颈 重点优化项改造 优化效果验证 建立压测评估链路 服务性能评估 构造请求流量 压测范围 性能数据采集 分析性能火焰图，定位性能瓶颈 pprof 火焰图 重点优化项分析 规范组件库使用 高并发场景优化 增加代码检查规则避免增量劣化出现 优化正确性验证 上线验证评估 逐步放量，避免出现问题 进一步优化，服务整体链路分析 规范上游服务调用接口，明确场景需求 分析业务流程，通过业务流程优化提升服务性能 基础库优化 适应范围更广，覆盖更多服务 AB 实验 SDK 的优化 分析基础库核心逻辑和性能瓶颈 完善改造方案，按需获取，序列化协议优化 内部压测验证 推广业务服务落地验证 Go 语言优化 适应范围最广，Go 服务都有收益 优化方式 优化内存分配策略 优化代码编译流程，生成更高效的程序 内部压测验证 推广业务服务落地验证 "},{"title":"A New Start","date":"2022-03-16T13:16:10.987Z","url":"/2022/03/16/A-New-Start/","categories":[["记录","/categories/%E8%AE%B0%E5%BD%95/"]],"content":"A New StartForget the past No longer dependent Tomorrow is another day"},{"title":"MarkDown教程","date":"2022-03-16T07:05:39.896Z","url":"/2022/03/16/MarkDown%E6%95%99%E7%A8%8B/","categories":[["学习","/categories/%E5%AD%A6%E4%B9%A0/"]],"content":"MarkDown基础基础篇视频讲解链接画图篇视频讲解链接 标题 一级标题使用1个#二级标题使用2个#三级标题使用3个#四级标题使4用个#五级标题使用5个#六级标题使用6个######## 最多支持六级标题# 文字删除线 这就是 删除线 (使用波浪号) 斜体 这是用来 斜体 的 文本 加粗 这是用来 加粗 的 文本 斜体+加粗 这是用来 斜体+加粗 的 文本 下划线下划线是HTML语法 下划线 下划线(快捷键command+u，视频中所有的快捷键都是针对Mac系统，其他系统可自行查找) 高亮（需勾选扩展语法） 这是用来 &#x3D;&#x3D;斜体+加粗&#x3D;&#x3D; 的文本 下标（需勾选扩展语法） 水 H2O 双氧水 H2O2 上标（需勾选扩展语法） 面积 m^2^体积 m^3^ 表情符号 Emoji 支持表情符号，你可以用系统默认的 Emoji 符号（ Windows 用户不一定支持，自己试下~）。 也可以用图片的表情，输入 : 将会出现智能提示。 一些表情例子 :smile: :laughing: :dizzy_face: :sob: :cold_sweat: :sweat_smile: :cry: :triumph: :heart_eyes: :relaxed: :sunglasses: :weary: :+1: :-1: :100: :clap: :bell: :gift: :question: :bomb: :heart: :coffee: :cyclone: :bow: :kiss: :pray: :sweat_drops: :hankey: :exclamation: :anger: ( Mac: control+command+space点选) 表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行： 为了使 Markdown 更清晰，| 和 - 两侧需要至少有一个空格（最左侧和最右侧的 | 外就不需要了）。 name price fried chicken 19 cola 5 为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用 | 来标记单元格边界，在表头下方的分隔线标记中加入 :，即可标记下方单元格内容的对齐方式： name price fried chicken 19 cola 32 使用快捷键command+opt+T更方便(段落→表格→插入表格，即可查看快捷键) 引用 “后悔创业” 也可以在引用中 使用嵌套的引用 列表无序列表–符号 空格 可以使用 * 作为标记 也可以使用 + 或者 - 有序列表–数字 . 空格 有序列表以数字和 . 开始； 数字的序列并不会影响生成的列表序列； 但仍然推荐按照自然顺序（1.2.3…）编写。 代码代码块 行内代码 Markdown 转换规则代码块中的文本（包括 Markdown 语法）都会显示为原始内容 分隔线可以在一行中使用三个或更多的 *、- 或 _ 来添加分隔线（&#96;&#96;）： 跳转外部跳转–超链接格式为 [link text](link)。 帮助文档 内部跳转–本文件内跳（Typora支持）格式为 [link text](#要去的目的地--标题）。 Open Links in Typora You can use command+click (macOS), or ctrl+click (Linux&#x2F;Windows) on links in Typora to jump to target headings, or open them in Typora, or open in related apps. 我想跳转 自动链接使用 &lt;&gt; 包括的 URL 或邮箱地址会被自动转换为超链接：  123@email.com 图片 网上的图片 本地图片 利用Markdown画图（需勾选扩展语法） markdown画图也是轻量级的，功能并不全。 Mermaid 是一个用于画流程图、状态图、时序图、甘特图的库，使用 JS 进行本地渲染，广泛集成于许多 Markdown 编辑器中。Mermaid 作为一个使用 JS 渲染的库，生成的不是一个“图片”，而是一段 HTML 代码。 （不同的编辑器渲染的可能不一样） 流程图(graph)概述 关键字graph表示一个流程图的开始，同时需要指定该图的方向。 其中“方向描述”为： 用词 含义 TB 从上到下 BT 从下到上 RL 从右到左 LR 从左到右 T &#x3D; TOP，B &#x3D; BOTTOM，L &#x3D; LEFT，R &#x3D; RIGHT，D &#x3D; DOWN 最常用的布局方向是TB、LR。 流程图常用符号及含义节点形状 表述 说明 含义 id[文字] 矩形节点 表示过程，也就是整个流程中的一个环节 id(文字) 圆角矩形节点 表示开始和结束 id((文字)) 圆形节点 表示连接。为避免流程过长或有交叉，可将流程切开。成对 id{文字} 菱形节点 表示判断、决策 id&gt;文字] 右向旗帜状节点 单向箭头线段：表示流程进行方向 id即为节点的唯一标识，A~F 是当前节点名字，类似于变量名，画图时便于引用 括号内是节点中要显示的文字，默认节点的名字和显示的文字都为A 连线 子图表使用以下语法添加子图表 序列图(sequence diagram)概述 sequenceDiagram 为每幅时序图的固定开头 参与者（participant）传统时序图概念中参与者有角色和类对象之分，但这里我们不做此区分，用参与者表示一切参与交互的事物，可以是人、类对象、系统等形式。中间竖直的线段从上至下表示时间的流逝。 participant &lt;参与者名称&gt; 声明参与者，语句次序即为参与者横向排列次序。 消息线 类型 描述 -&gt; 无箭头的实线 –&gt; 无箭头的虚线 -&gt;&gt; 有箭头的实线（主动发出消息） –-&gt;&gt; 有箭头的虚线（响应） -x 末端为叉的实线（表示异步） –x 末端为叉的虚线（表示异步） 处理中-激活框从消息接收方的时间线上标记一小段时间，表示对消息进行处理的时间间隔。 在消息线末尾增加 + ，则消息接收者进入当前消息的“处理中”状态；在消息线末尾增加 - ，则消息接收者离开当前消息的“处理中”状态。 注解（note）语法如下 其中位置表述可以为 表述 含义 right of 右侧 left of 左侧 over 在当中，可以横跨多个参与者 循环（loop）在条件满足时，重复发出消息序列。（相当于编程语言中的 while 语句。） 选择（alt）在多个条件中作出判断，每个条件将对应不同的消息序列。（相当于 if 及 else if 语句。） 可选（opt）在某条件满足时执行消息序列，否则不执行。相当于单个分支的 if 语句。 并行（Par）将消息序列分成多个片段，这些片段并行执行。 饼图（Pie） Typora支持mermaid的官方链接 甘特图（gantt） 官方教程 "}]